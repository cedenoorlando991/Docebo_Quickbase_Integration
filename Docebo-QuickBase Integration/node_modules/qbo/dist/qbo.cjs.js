'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('core-js/modules/es.object.keys');
require('core-js/modules/es.array.concat');
require('core-js/modules/es.array.filter');
require('core-js/modules/es.array.find');
require('core-js/modules/es.array.for-each');
require('core-js/modules/es.array.includes');
require('core-js/modules/es.array.index-of');
require('core-js/modules/es.array.iterator');
require('core-js/modules/es.array.join');
require('core-js/modules/es.array.map');
require('core-js/modules/es.array.sort');
require('core-js/modules/es.function.name');
require('core-js/modules/es.number.to-fixed');
require('core-js/modules/es.object.to-string');
require('core-js/modules/es.regexp.constructor');
require('core-js/modules/es.regexp.exec');
require('core-js/modules/es.regexp.to-string');
require('core-js/modules/es.set');
require('core-js/modules/es.string.iterator');
require('core-js/modules/es.string.match');
require('core-js/modules/es.string.replace');
require('core-js/modules/es.string.split');
require('core-js/modules/es.string.trim');
require('core-js/modules/web.dom-collections.for-each');
require('core-js/modules/web.dom-collections.iterator');
var xpath = _interopDefault(require('xpath'));
var xmldom = _interopDefault(require('xmldom'));
require('regenerator-runtime/runtime');
var axios = _interopDefault(require('axios'));
require('core-js/modules/es.array.slice');
require('core-js/modules/es.promise');

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var DOMParser = xmldom.DOMParser;
var extract_xml_values = function extract_xml_values(text, names) {
  var xml = new DOMParser().parseFromString(text);
  return forMap(names, function (name) {
    var node = xpath.select1("//" + name, xml);

    if (!is_blank(node)) {
      return node.textContent;
    }
  });
};
var xml_attrs = function xml_attrs(node) {
  var obj = {};
  forEach(node.attributes, function (attr) {
    if (typeof attr.name != 'undefined') {
      obj[attr.name] = attr.value;
    }
  });
  return obj;
};
var xml_child_tags = function xml_child_tags(node) {
  var obj = {};
  xml_each_child(node, function (prop) {
    obj[prop.localName] = prop.textContent;
  });
  return obj;
};
var xml_each_child = function xml_each_child(node, fn) {
  forEach(node.childNodes, function (child) {
    if (child.nodeType == 1) {
      fn(child);
    }
  });
};
var trim = function trim(s) {
  return s.trim();
};
var isObject = function isObject(o) {
  return _typeof(o) === 'object';
};
var isEmptyObject = function isEmptyObject(o) {
  for (var key in o) {
    if (o.hasOwnProperty(key)) {
      return false;
    }
  }

  return true;
};
var isFunction = function isFunction(f) {
  return typeof f === 'function';
};
var isString = function isString(s) {
  return typeof s === 'string';
};
var isBlankString = function isBlankString(s) {
  return isString(s) && trim(s) === '';
};
var isNonBlankString = function isNonBlankString(s) {
  return isString(s) && trim(s) !== '';
};
var isIntegerString = function isIntegerString(s) {
  return (typeof s === 'number' || typeof s === 'string') && parseInt(s) + '' === s + '';
};
var isTrueOrFalse = function isTrueOrFalse(s) {
  return s === 'true' || s === 'false';
};
var parseIntString = function parseIntString(v) {
  return parseInt(v).toString();
};
var isZeroOrOne = function isZeroOrOne(v) {
  return [0, 1].includes(parseInt(v));
};
var getProperty = function getProperty(object, propertyName) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      defaultValue = _ref.defaultValue,
      validate = _ref.validate,
      normalize = _ref.normalize;

  if (!isObject(object) || isBlankString(propertyName)) {
    return undefined;
  }

  if (object[propertyName] === undefined) {
    return defaultValue;
  }

  var value = object[propertyName];

  if (validate && isFunction(validate)) {
    if (validate(value) !== true) {
      return defaultValue;
    }
  }

  if (normalize && isFunction(normalize)) {
    value = normalize(value);
  }

  return value;
};
var cdata = function cdata(s) {
  return "<![CDATA[".concat(s, "]]>");
};
var EN_MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var EN_MONTHS_LONG = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var EN_WEEKDAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var EN_WEEKDAYS_LONG = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var underscorize = function underscorize(str) {
  var result = str.toLowerCase().replace(/[^A-Za-z0-9]/g, "_");

  if (result.match(/^\d/) != null) {
    result = "n" + result;
  }

  return result;
};
var isHash = function isHash(item) {
  return item && _typeof(item) === 'object' && !Array.isArray(item);
};
var mergeDeep = function mergeDeep(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (!sources.length) return target;
  var source = sources.shift();

  if (isHash(target) && isHash(source)) {
    for (var key in source) {
      if (isHash(source[key])) {
        if (!target[key]) {
          target[key] = {};
        }

        mergeDeep(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }

  return mergeDeep.apply(void 0, [target].concat(sources));
};
var addCommas = function addCommas(nStr) {
  nStr += '';
  var x = nStr.split('.');
  var x1 = x[0];
  var x2 = x.length > 1 ? '.' + x[1] : '';
  var rgx = /(\d+)(\d{3})/;

  while (rgx.test(x1)) {
    x1 = x1.replace(rgx, '$1' + ',' + '$2');
  }

  return x1 + x2;
};
function parseNumber(str) {
  if (typeof str === "number") {
    return str;
  }

  str = parseNumberStr(str);

  if (str.match('.')) {
    return parseFloat(str);
  } else {
    return parseInt(str);
  }
}
function parseNumberStr(str) {
  if (typeof str !== "string") {
    return '';
  }

  return str.replace(/,/g, "").replace(/[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6]/, "").replace(/%/, "");
}
var getURLParameter = function getURLParameter(name, url) {
  var qry = location.href.split("?")[1];

  if (typeof url != "undefined") {
    qry = url.split("?")[1];
  }

  name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("(^|&)" + name + "=([^&#]*)"),
      results = regex.exec(qry);
  return results === null ? "" : decodeURIComponent(results[2].replace(/\+/g, " "));
};
var is_blank = function is_blank(str) {
  return typeof str == "undefined" || str == "" || str == null || Object.prototype.toString.call(str) === '[object Array]' && str.length == 0;
};
var is_true = function is_true(str) {
  var n_str = ("" + str).toLowerCase();
  return n_str == "yes" || n_str == "1" || n_str == "true";
};
var is_false = function is_false(str) {
  var n_str = ("" + str).toLowerCase();
  return n_str == "no" || n_str == "0" || n_str == "false";
};
var to_date = function to_date(str) {
  var strs = str.split("-");

  if (strs.length == 3) {
    var nums = forMap(strs, function (s) {
      return parseInt(s, 10);
    });

    if (isNaN(nums[0])) {
      nums[0] = EN_MONTHS.indexOf(strs[0]);
    } else {
      nums[0]--;
    }

    return new Date(nums[2], nums[0], nums[1]);
  } else {
    return new Date(parseInt(str, 10));
  }
};
var to_bool = function to_bool(str) {
  return is_true(str);
};
var to_arr = function to_arr(str) {
  var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ",";

  if (str == "") {
    return [];
  } else {
    return forMap(str.split(delimiter), function (s) {
      return s.trim();
    });
  }
};
var to_currency = function to_currency(num) {
  var decimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "$";

  if (typeof num != "number") {
    num = parseNumber(num);
  }

  return sign + addCommas(num.toFixed(decimal));
};
var to_percent = function to_percent(num) {
  var decimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (typeof num != "number") {
    num = parseNumber(num);
  }

  num = num.toFixed(decimal);
  return "" + num + "%";
};
var validate_email = function validate_email(email) {
  var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(String(email).toLowerCase());
};
var validate_url = function validate_url(val) {
  return /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(val);
};
function forEach(input, fn) {
  if (Array.isArray(input)) {
    input.forEach(function (val, key) {
      fn(val, key);
    });
  } else {
    Object.keys(input).forEach(function (key) {
      fn(input[key], key);
    });
  }
}
function forMap(input, fn) {
  if (Array.isArray(input)) {
    return input.map(function (val, key) {
      return fn(val, key);
    });
  } else {
    var arr = [];
    Object.keys(input).forEach(function (key) {
      arr.push(fn(input[key], key));
    });
    return arr;
  }
}
function sort_by(input, attr) {
  input.sort(function (a, b) {
    var str_a = a[attr].toLowerCase();
    var str_b = b[attr].toLowerCase();
    if (str_a < str_b) return -1;
    if (str_a > str_b) return 1;
    return 0;
  });
}
function get_obj(input, conds, opt) {
  validate_undefined_attr(conds, "get_obj");
  return input.find(function (item) {
    var found_false = Object.keys(conds).find(function (key) {
      return !match_x_y(item[key], conds[key], opt);
    });
    return typeof found_false == "undefined";
  });
}
function get_objs(input, conds, opt) {
  validate_undefined_attr(conds, "get_objs");
  return input.filter(function (item) {
    var found_false = Object.keys(conds).find(function (key) {
      return !match_x_y(item[key], conds[key], opt);
    });
    return typeof found_false == "undefined";
  });
}

function match_x_y(x, y) {
  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var a = "" + x;
  var b = "" + y;

  if (opt.case_insensitive == true) {
    a = a.toLowerCase();
    b = b.toLowerCase();
  }

  if (opt.sub_match == true) {
    return a.match(b) != null;
  } else {
    return a == b;
  }
}

function validate_undefined_attr(conds, fn_name) {
  forEach(conds, function (val, key) {
    if (typeof val == "undefined") {
      var msg = key + " is undefined in " + fn_name + ": " + JSON.stringify(conds);
      throw new Error(msg);
    }
  });
}

function update_obj(input, conds, attrs) {
  var obj = get_obj(input, conds);
  forEach(attrs, function (v, attr) {
    obj[attr] = v;
  });
}
function update_objs(input, conds, attrs) {
  var objs = get_objs(input, conds);
  forEach(objs, function (obj) {
    forEach(attrs, function (attr, v) {
      obj[attr] = v;
    });
  });
}
function uniq_arr(input) {
  return _toConsumableArray(new Set(input));
}
function pad_0(input, size) {
  var s = input + "";

  while (s.length < size) {
    s = "0" + s;
  }

  return s;
}
function to_ymd(input, delimiter) {
  if (isNaN(input.getTime())) {
    return "";
  } else {
    if (typeof delimiter == "undefined") {
      delimiter = "-";
    }

    return [input.getFullYear(), pad_0(input.getMonth() + 1, 2), pad_0(input.getDate(), 2)].join(delimiter);
  }
}
function to_mdy(input, delimiter) {
  if (isNaN(input.getTime())) {
    return "";
  } else {
    if (typeof delimiter == "undefined") {
      delimiter = "-";
    }

    return [pad_0(input.getMonth() + 1, 2), pad_0(input.getDate(), 2), input.getFullYear()].join(delimiter);
  }
}
function to_dmy(input, delimiter) {
  if (isNaN(input.getTime())) {
    return "";
  } else {
    if (typeof delimiter == "undefined") {
      delimiter = "-";
    }

    return [pad_0(input.getDate(), 2), pad_0(input.getMonth() + 1, 2), input.getFullYear()].join(delimiter);
  }
}
function to_md(input) {
  if (isNaN(input.getTime())) {
    return "";
  } else {
    return EN_MONTHS[input.getMonth()] + " " + input.getDate();
  }
}
function to_timestamp(input, delimiter) {
  if (isNaN(input.getTime())) {
    return "";
  } else {
    return to_ymd(input, delimiter) + " " + pad_0(input.getHours(), 2) + ":" + pad_0(input.getMinutes(), 2) + ":" + pad_0(input.getSeconds(), 2);
  }
}
function encode_html(input) {
  return ('' + input).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
}
function decode_html(input) {
  return ('' + input).replace(/&apos;/g, "'").replace(/&quot;/g, '"').replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&amp;/g, '&');
}
function encode_xml(input) {
  return ('' + input).replace(/[<>&'"]/g, function (c) {
    switch (c) {
      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '&':
        return '&amp;';

      case '\'':
        return '&apos;';

      case '"':
        return '&quot;';
    }
  });
}

var utilities = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DOMParser: DOMParser,
  extract_xml_values: extract_xml_values,
  xml_attrs: xml_attrs,
  xml_child_tags: xml_child_tags,
  xml_each_child: xml_each_child,
  trim: trim,
  isObject: isObject,
  isEmptyObject: isEmptyObject,
  isFunction: isFunction,
  isString: isString,
  isBlankString: isBlankString,
  isNonBlankString: isNonBlankString,
  isIntegerString: isIntegerString,
  isTrueOrFalse: isTrueOrFalse,
  parseIntString: parseIntString,
  isZeroOrOne: isZeroOrOne,
  getProperty: getProperty,
  cdata: cdata,
  EN_MONTHS: EN_MONTHS,
  EN_MONTHS_LONG: EN_MONTHS_LONG,
  EN_WEEKDAYS: EN_WEEKDAYS,
  EN_WEEKDAYS_LONG: EN_WEEKDAYS_LONG,
  underscorize: underscorize,
  isHash: isHash,
  mergeDeep: mergeDeep,
  addCommas: addCommas,
  parseNumber: parseNumber,
  parseNumberStr: parseNumberStr,
  getURLParameter: getURLParameter,
  is_blank: is_blank,
  is_true: is_true,
  is_false: is_false,
  to_date: to_date,
  to_bool: to_bool,
  to_arr: to_arr,
  to_currency: to_currency,
  to_percent: to_percent,
  validate_email: validate_email,
  validate_url: validate_url,
  forEach: forEach,
  forMap: forMap,
  sort_by: sort_by,
  get_obj: get_obj,
  get_objs: get_objs,
  update_obj: update_obj,
  update_objs: update_objs,
  uniq_arr: uniq_arr,
  pad_0: pad_0,
  to_ymd: to_ymd,
  to_mdy: to_mdy,
  to_dmy: to_dmy,
  to_md: to_md,
  to_timestamp: to_timestamp,
  encode_html: encode_html,
  decode_html: decode_html,
  encode_xml: encode_xml
});

var supportedActions = {
  API_CopyMasterDetail: {
    destrid: {
      defaultValue: 0,
      validate: isIntegerString,
      normalize: parseIntString
    },
    sourcerid: {
      defaultValue: 0,
      validate: isIntegerString,
      normalize: parseIntString
    },
    copyfid: {
      defaultValue: null,
      validate: isIntegerString,
      normalize: parseIntString
    },
    recurse: {
      defaultValue: 'true',
      validate: isTrueOrFalse,
      normalize: trim
    },
    relfids: {
      defaultValue: 'all',
      validate: isNonBlankString,
      normalize: trim
    },
    udata: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_DoQuery: {
    query: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    qid: {
      defaultValue: null,
      validate: isIntegerString,
      normalize: parseIntString
    },
    qname: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    clist: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    slist: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    fmt: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    returnpercentage: {
      defaultValue: null,
      validate: isZeroOrOne,
      normalize: parseIntString
    },
    options: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    includeRids: {
      defaultValue: null,
      validate: isZeroOrOne,
      normalize: parseIntString
    },
    udata: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_DoQueryCount: {
    query: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_GenResultsTable: {
    query: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    qid: {
      defaultValue: null,
      validate: isIntegerString,
      normalize: parseIntString
    },
    qname: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    clist: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    slist: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    options: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    udata: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    jht: {
      defaultValue: null
    },
    jsa: {
      defaultValue: null,
      validate: isZeroOrOne,
      normalize: parseIntString
    }
  },
  API_GetUserInfo: {
    email: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    udata: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_ImportFromCSV: {
    records_csv: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: cdata
    },
    clist: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    clist_output: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    skipfirst: {
      defaultValue: null,
      validate: isZeroOrOne,
      normalize: parseIntString
    },
    msInUTC: {
      defaultValue: null,
      validate: isZeroOrOne,
      normalize: parseIntString
    },
    mergeFieldId: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    udata: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_PurgeRecords: {
    query: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    qid: {
      defaultValue: null,
      validate: isIntegerString,
      normalize: parseIntString
    },
    qname: {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_RunImport: {
    "id": {
      defaultValue: null,
      validate: isIntegerString,
      normalize: parseIntString
    },
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_GenAddRecordForm: {
    fields: {
      defaultValue: null,
      validate: isObject
    }
  },
  API_GetSchema: {
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_UserRoles: {
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_AddUserToRole: {
    "userid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "roleid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_GetUserRole: {
    "userid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "inclgrps": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_ChangeUserRole: {
    "userid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "roleid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "newroleid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_ProvisionUser: {
    "email": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "roleid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "fname": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "lname": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_UploadFile: {
    "field": {
      defaultValue: null,
      validate: isObject
    },
    "rid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_AddRecord: {
    "fields": {
      defaultValue: null,
      validate: isObject
    },
    "update_id": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "msInUTC": {
      defaultValue: null,
      validate: isZeroOrOne,
      normalize: parseIntString
    },
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_EditRecord: {
    "fields": {
      defaultValue: null,
      validate: isObject
    },
    "update_id": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "msInUTC": {
      defaultValue: null,
      validate: isZeroOrOne,
      normalize: parseIntString
    },
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "rid": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "key": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_CreateTable: {
    "tname": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "pnoun": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_AddField: {
    "label": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "type": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    },
    "mode": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  },
  API_Authenticate: {
    "hour": {
      defaultValue: null,
      validate: isIntegerString,
      normalize: parseIntString
    },
    "udata": {
      defaultValue: null,
      validate: isNonBlankString,
      normalize: trim
    }
  }
};

var XmlRequest = /*#__PURE__*/function () {
  function XmlRequest(db_url, clientConfig) {
    var _this = this;

    _classCallCheck(this, XmlRequest);

    if (!isString(db_url) || isBlankString(db_url)) {
      throw new Error('Argument \'db_url\' must be a non-empty string');
    }

    this.url = db_url.trim();
    this.xmlBuffer = [];
    [{
      parameter: 'ticket',
      options: {
        validate: isNonBlankString,
        normalize: trim
      }
    }, {
      parameter: 'username',
      options: {
        validate: isNonBlankString,
        normalize: trim
      }
    }, {
      parameter: 'password',
      options: {
        validate: isNonBlankString,
        normalize: trim
      }
    }, {
      parameter: 'usertoken',
      options: {
        validate: isNonBlankString,
        normalize: trim
      }
    }, {
      parameter: 'apptoken',
      options: {
        validate: isNonBlankString,
        normalize: trim
      }
    }].forEach(function (_ref) {
      var parameter = _ref.parameter,
          options = _ref.options;
      var value = getProperty(clientConfig, parameter, options);

      if (value) {
        //this[parameter] = value;
        _this.addXmlParameter(parameter, encode_xml(value));
      }
    });
  }

  _createClass(XmlRequest, [{
    key: "addXmlParameter",
    value: function addXmlParameter() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var attrs = arguments.length > 2 ? arguments[2] : undefined;
      name = trim(name);
      value = value.toString();
      var attrs_str = '';

      if (typeof attrs !== 'undefined') {
        attrs_str = ' ' + forMap(attrs, function (v, k) {
          return "".concat(encode_xml(k), "=\"").concat(encode_xml(v), "\"");
        }).join(' ') + ' ';
      }

      this.xmlBuffer.push('<' + name + attrs_str + '>' + value + '</' + name + '>'); //this[name] = value;
    }
  }, {
    key: "xmlBufferToString",
    value: function xmlBufferToString() {
      return '<qdbapi>' + this.xmlBuffer.join('') + '</qdbapi>';
    }
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(action, _ref2) {
        var proxy_url,
            settings,
            loggers_debuggers,
            url,
            opt,
            res,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                proxy_url = _ref2.proxy_url, settings = _objectWithoutProperties(_ref2, ["proxy_url"]);
                loggers_debuggers = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                url = this.url + '?act=' + action;

                if (!isBlankString(proxy_url)) {
                  url = proxy_url + "?ori_url=" + encodeURI(url);
                }

                opt = mergeDeep({}, {
                  url: url,
                  method: 'post',
                  headers: {
                    'Content-Type': 'application/xml',
                    'QUICKBASE-ACTION': action
                  },
                  data: this.xmlBufferToString(),
                  responseType: 'text'
                }, settings);

                if (loggers_debuggers.log_request_opt) {
                  loggers_debuggers.log_request_opt(opt);
                }

                _context.next = 8;
                return axios(opt);

              case 8:
                res = _context.sent;
                return _context.abrupt("return", res.data);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function send(_x, _x2) {
        return _send.apply(this, arguments);
      }

      return send;
    }()
  }]);

  return XmlRequest;
}();

var QuickBaseClient = /*#__PURE__*/function () {
  function QuickBaseClient() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var loggers_debuggers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, QuickBaseClient);

    this.config = _objectSpread2({
      settings: {}
    }, config);
    this.request = null;
    forEach(supportedActions, function (opt, name) {
      QuickBaseClient.prototype[name] = function (db_url, parameters, settings) {
        return _this.invoke(name, db_url, parameters, settings, loggers_debuggers);
      };
    });
  }

  _createClass(QuickBaseClient, [{
    key: "invoke",
    value: function invoke(action, db_url) {
      var _this2 = this;

      var parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var loggers_debuggers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      if (!isString(action) || isBlankString(action)) {
        throw new Error('Argument \'action\' must be a non-empty string');
      }

      if (!isString(db_url) || isBlankString(db_url)) {
        throw new Error('Argument \'db_url\' must be a non-empty string');
      }

      var actionConfig = supportedActions[action];

      if (!isObject(actionConfig) || isEmptyObject(actionConfig)) {
        throw new Error('The specified action is not currently supported by this client: ' + action);
      }

      this.request = new XmlRequest(db_url, this.config);
      parameters = isObject(parameters) ? parameters : {};
      settings = isObject(settings) ? settings : {};
      forEach(actionConfig, function (options, parameter) {
        var value = getProperty(parameters, parameter, options);

        if (value) {
          if (isObject(value)) {
            if (Array.isArray(value)) {
              forEach(value, function (v) {
                //this.request[k] = v.value;
                _this2.request.addXmlParameter(v.name ? v.name : 'field', v.value, v.attrs);
              });
            } else {
              //this.request[parameter] = value.value;
              _this2.request.addXmlParameter(parameter, value.value, value.attrs);
            }
          } else {
            //this.request[parameter] = value;
            _this2.request.addXmlParameter(parameter, value);
          }
        }
      });
      return this.request.send(action, mergeDeep({}, this.config.settings, settings), loggers_debuggers);
    }
  }]);

  return QuickBaseClient;
}();

var QBAPIError = /*#__PURE__*/function (_Error) {
  _inherits(QBAPIError, _Error);

  var _super = _createSuper(QBAPIError);

  function QBAPIError(message) {
    var _this;

    _classCallCheck(this, QBAPIError);

    _this = _super.call(this, "QB API ERROR: " + message); // Ensure the name of this error is the same as the class name

    _this.name = _this.constructor.name; // This clips the constructor invocation from the stack trace.
    // It's not absolutely essential, but it does make the stack trace a little nicer.
    //  @see Node.js reference (bottom)

    if (Error.captureStackTrace && typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    }

    return _this;
  }

  return QBAPIError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var default_converts = {
  checkbox: is_true,
  duration: parseNumber,
  number: parseNumber,
  currency: parseNumber,
  percent: parseNumber
};
var default_max_num = 4294967296;

var QBOFactory = /*#__PURE__*/function () {
  function QBOFactory() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$application_url = _ref.application_url,
        application_url = _ref$application_url === void 0 ? null : _ref$application_url;

    _classCallCheck(this, QBOFactory);

    this.apptoken = "";
    this.usertoken = "";
    this.application_url = application_url;

    if (!this.application_url && typeof window !== 'undefined') {
      this.application_url = window.location.origin + window.location.pathname;
    }

    this.proxy_url = "";
    this.klasses = [];
    this.auto_clist_output = false;
    this.save_undefined_as_empty = false;
    this.max_num = default_max_num;
    this.chunk_size = default_max_num;
    this.save_chunk_size = default_max_num;
    this.concat_chunks = true;
    this.loggers_debuggers = {}; // {log_request_opt: opt => console.log(opt)}

    this.current_user = null;
    forEach(supportedActions, function (val, action) {
      _this[action] = function (cls) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var default_params = {};
        var db_map = params.db_map;

        if (typeof db_map == "undefined") {
          db_map = cls.db_map;
        }

        if (_this.check_db_map(cls, db_map)) {
          if (typeof cls == "string") {
            default_params = mergeDeep({}, default_params, {
              options: {
                num: _this.max_num,
                skp: "0",
                sortorder: "A"
              },
              apptoken: _this.apptoken,
              usertoken: _this.usertoken,
              ticket: _this.ticket,
              username: _this.username,
              password: _this.password,
              proxy_url: _this.proxy_url
            });
          } else {
            default_params = mergeDeep({}, default_params, {
              clist: _this.clist(db_map),
              options: {
                num: _this.max_num,
                skp: "0",
                sortorder: "A"
              },
              apptoken: cls.apptoken ? cls.apptoken : _this.apptoken,
              usertoken: cls.usertoken ? cls.usertoken : _this.usertoken,
              ticket: cls.ticket ? cls.ticket : _this.ticket,
              username: cls.username ? cls.username : _this.username,
              password: cls.password ? cls.password : _this.password,
              proxy_url: cls.proxy_url ? cls.proxy_url : _this.proxy_url,
              auto_clist_output: cls.auto_clist_output ? cls.auto_clist_output : _this.auto_clist_output
            });

            if (default_params.auto_clist_output) {
              default_params.clist_output = _this.clist(cls.db_map);
            }
          }

          params = mergeDeep({}, default_params, params);
          params.options = _this.options_to_string(params.options);
          var config = {
            apptoken: params.apptoken,
            usertoken: params.usertoken,
            ticket: params.ticket,
            username: params.username,
            password: params.password,
            settings: {
              proxy_url: params.proxy_url
            }
          };
          var client = new QuickBaseClient(config, _this.loggers_debuggers);
          var url = cls;

          if (typeof cls != "string") {
            url = cls.url();
          }

          return client[action](url, params);
        }
      };
    });
  }

  _createClass(QBOFactory, [{
    key: "to_file_arr",
    value: function to_file_arr(str) {
      if (str == "") {
        return ["", ""];
      } else {
        var urls = str.split("https://");
        return [urls[0], "https://" + urls[1]];
      }
    }
  }, {
    key: "to_file_link",
    value: function to_file_link(str) {
      if (str == "") {
        return "";
      } else {
        var urls = str.split("https://");
        return "<a href='https://" + urls[1] + "' target='_blank'>" + urls[0] + "</a>";
      }
    }
  }, {
    key: "is_readonly_field",
    value: function is_readonly_field(m) {
      if (m.readonly == true) {
        return true;
      } else {
        var name = ["lookup", "formula", "system", "readonly"].find(function (n) {
          return n == m.field_type;
        });
        return typeof name != "undefined";
      }
    }
  }, {
    key: "is_fake_field",
    value: function is_fake_field(m) {
      return m.is_fake == true;
    }
  }, {
    key: "is_writable_field",
    value: function is_writable_field(m) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return !this.is_readonly_field(m) && !this.is_fake_field(m) && (is_blank(params.mergeFieldId) || m.name != "rid");
    }
  }, {
    key: "writable_map",
    value: function writable_map(db_map, params) {
      var _this2 = this;

      return db_map.filter(function (m) {
        return _this2.is_writable_field(m, params);
      });
    }
  }, {
    key: "clist",
    value: function clist(db_map) {
      var _this3 = this;

      return forMap(db_map.filter(function (m) {
        return !_this3.is_fake_field(m);
      }), function (m) {
        return m.fid;
      }).join(".");
    }
  }, {
    key: "map_saved_obj",
    value: function map_saved_obj(obj, node) {
      var _this4 = this;

      var cls = obj.constructor;
      xml_each_child(node, function (field) {
        forEach(field.attributes, function (attr) {
          if (attr.name == "id") {
            _this4.assign_and_convert_field(obj, get_obj(cls.db_map, {
              fid: attr.value
            }), field.textContent);
          }
        });
      });
      if (typeof cls.after_load != "undefined") cls.after_load(obj);
      return obj;
    }
  }, {
    key: "assign_and_convert_field",
    value: function assign_and_convert_field(obj, map, val) {
      obj[map.name] = val;

      if (map.valueToData) {
        obj[map.name] = map.valueToData(obj[map.name]);
      } else if (typeof map.convert == "undefined") {
        if (default_converts[map.field_type]) {
          obj[map.name] = default_converts[map.field_type](obj[map.name]);
        }
      } else {
        var fn_name = map.convert.name;
        if (fn_name == "parseInt" || fn_name == "parseFloat") obj[map.name] = obj[map.name].replace(/,/g, "");
        obj[map.name] = map.convert(obj[map.name]);
      }
    }
  }, {
    key: "throw_deleted_field_error",
    value: function () {
      var _throw_deleted_field_error = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cls) {
        var fids;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                fids = [];
                _context.next = 3;
                return cls.set_schema_fields(false);

              case 3:
                cls.db_map.forEach(function (m) {
                  var found = cls.schema_fields.find(function (f) {
                    return f.id === m.fid;
                  });

                  if (!found) {
                    fids.push(m.fid);
                  }
                });
                throw new Error("Field ID ".concat(fids.join(', '), " was deleted from table ").concat(cls.table_label, " which the code uses. Please contact the programmer."));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function throw_deleted_field_error(_x) {
        return _throw_deleted_field_error.apply(this, arguments);
      }

      return throw_deleted_field_error;
    }()
  }, {
    key: "map_obj",
    value: function map_obj(cls, data_arr, db_map) {
      var _this5 = this;

      var obj = new cls();
      forEach(db_map, function (map, i) {
        _this5.assign_and_convert_field(obj, map, data_arr[i]);
      });
      if (typeof cls.after_load != "undefined") cls.after_load(obj);
      return obj;
    }
  }, {
    key: "map_objs",
    value: function () {
      var _map_objs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cls, data_arrs, db_map) {
        var _this6 = this;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                db_map = db_map.filter(function (m) {
                  return m.is_fake != true;
                });

                if (!(data_arrs[0] && data_arrs[0].length != db_map.length)) {
                  _context2.next = 4;
                  break;
                }

                _context2.next = 4;
                return this.throw_deleted_field_error(cls);

              case 4:
                return _context2.abrupt("return", forMap(data_arrs, function (a) {
                  return _this6.map_obj(cls, a, db_map);
                }));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function map_objs(_x2, _x3, _x4) {
        return _map_objs.apply(this, arguments);
      }

      return map_objs;
    }()
  }, {
    key: "map_xml_objs",
    value: function () {
      var _map_xml_objs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(cls, text, db_map) {
        var _this7 = this;

        var records, xml, nodes, _loop, i;

        return regeneratorRuntime.wrap(function _callee3$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                records = [];

                if (typeof db_map == "undefined") {
                  db_map = cls.db_map;
                }

                db_map = db_map.filter(function (m) {
                  return m.is_fake != true;
                });
                xml = new DOMParser().parseFromString(text);
                nodes = xpath.select("//record", xml);
                _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop(i) {
                  var field_count, data_arr;
                  return regeneratorRuntime.wrap(function _loop$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          field_count = 0;
                          data_arr = [];
                          xml_each_child(nodes[i], function (field) {
                            if (field.localName != "update_id") {
                              field_count++;
                              data_arr.push(field.textContent);
                            }
                          });

                          if (!(field_count != db_map.length)) {
                            _context3.next = 6;
                            break;
                          }

                          _context3.next = 6;
                          return _this7.throw_deleted_field_error(cls);

                        case 6:
                          records.push(_this7.map_obj(cls, data_arr, db_map));

                        case 7:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _loop);
                });
                _context4.t0 = regeneratorRuntime.keys(nodes);

              case 7:
                if ((_context4.t1 = _context4.t0()).done) {
                  _context4.next = 12;
                  break;
                }

                i = _context4.t1.value;
                return _context4.delegateYield(_loop(i), "t2", 10);

              case 10:
                _context4.next = 7;
                break;

              case 12:
                return _context4.abrupt("return", records);

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee3);
      }));

      function map_xml_objs(_x5, _x6, _x7) {
        return _map_xml_objs.apply(this, arguments);
      }

      return map_xml_objs;
    }()
  }, {
    key: "options_to_string",
    value: function options_to_string(options) {
      if (typeof options == "undefined") {
        return undefined;
      }

      return "skp-" + options.skp + ".sortorder-" + options.sortorder + ".num-" + options.num;
    }
  }, {
    key: "build_slist",
    value: function build_slist(cls, arr) {
      var _this8 = this;

      return arr.map(function (name) {
        return _this8.fid(cls, name);
      }).join('.');
    }
  }, {
    key: "call_api",
    value: function call_api(action, cls) {
      var _this9 = this;

      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (typeof params.query != "undefined") {
        params.query = this.build_query(cls, params.query);
      }

      if (typeof params.slist != 'undefined' && Array.isArray(params.slist)) {
        params.slist = this.build_slist(cls, params.slist);
      }

      var promise = new Promise(function (resolve, reject) {
        _this9[action](cls, params).then( /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(text) {
            var _this9$extract_script, data, err_str, _extract_xml_values, _extract_xml_values2, errcode, errtext, errdetail;

            return regeneratorRuntime.wrap(function _callee4$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!(options.script_response == true && text.match('qdbapi') === null)) {
                      _context5.next = 19;
                      break;
                    }

                    _context5.prev = 1;
                    _this9$extract_script = _this9.extract_script_response(text), data = _this9$extract_script.data, err_str = _this9$extract_script.err_str;

                    if (!(typeof err_str == "undefined")) {
                      _context5.next = 11;
                      break;
                    }

                    _context5.t0 = resolve;
                    _context5.next = 7;
                    return _this9.map_objs(cls, data, cls.db_map);

                  case 7:
                    _context5.t1 = _context5.sent;
                    (0, _context5.t0)(_context5.t1);
                    _context5.next = 12;
                    break;

                  case 11:
                    reject(new QBAPIError(err_str));

                  case 12:
                    _context5.next = 17;
                    break;

                  case 14:
                    _context5.prev = 14;
                    _context5.t2 = _context5["catch"](1);
                    reject(_context5.t2);

                  case 17:
                    _context5.next = 41;
                    break;

                  case 19:
                    if (!(options.form_response == true)) {
                      _context5.next = 23;
                      break;
                    }

                    resolve(text);
                    _context5.next = 41;
                    break;

                  case 23:
                    _extract_xml_values = extract_xml_values(text, ["errcode", "errtext", "errdetail"]), _extract_xml_values2 = _slicedToArray(_extract_xml_values, 3), errcode = _extract_xml_values2[0], errtext = _extract_xml_values2[1], errdetail = _extract_xml_values2[2];

                    if (!(errcode == "0")) {
                      _context5.next = 40;
                      break;
                    }

                    if (!(typeof options.response_fn != "undefined")) {
                      _context5.next = 29;
                      break;
                    }

                    resolve(options.response_fn(text));
                    _context5.next = 38;
                    break;

                  case 29:
                    if (!(typeof options.data_fn != "undefined")) {
                      _context5.next = 37;
                      break;
                    }

                    _context5.t3 = resolve;
                    _context5.next = 33;
                    return options.data_fn(text);

                  case 33:
                    _context5.t4 = _context5.sent;
                    (0, _context5.t3)(_context5.t4);
                    _context5.next = 38;
                    break;

                  case 37:
                    resolve(text);

                  case 38:
                    _context5.next = 41;
                    break;

                  case 40:
                    reject(new QBAPIError(errtext + ": " + errdetail));

                  case 41:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee4, null, [[1, 14]]);
          }));

          return function (_x8) {
            return _ref2.apply(this, arguments);
          };
        }(), function (textStatus) {
          reject(new QBAPIError(textStatus));
        });
      });
      return promise;
    }
  }, {
    key: "extract_script_response",
    value: function extract_script_response(text) {
      var res = {};
      (0, eval)(text);

      if (text.match("document\\.write")) {
        res.err_str = "ERORR: " + text.match(/<div id=\\x22response_errormsg\\x22>(.*?)<\\\/div>/)[1];
      } else {
        (0, eval)(text);

        if (typeof qdb_data != "undefined") {
          res.data = qdb_data;
        }
      }

      return res;
    }
  }, {
    key: "load_chunks",
    value: function load_chunks(action, cls) {
      var _this10 = this;

      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var options = arguments.length > 3 ? arguments[3] : undefined;
      return new Promise( /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(resolve, reject) {
          var arr, concat_chunks, size, skp, count, records;
          return regeneratorRuntime.wrap(function _callee5$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  arr = [];
                  concat_chunks = typeof cls.concat_chunks === 'undefined' ? _this10.concat_chunks : cls.concat_chunks;
                  size = cls.chunk_size ? cls.chunk_size : _this10.chunk_size;
                  skp = 0;
                  count = size;
                  _context6.prev = 5;

                case 6:
                  if (!(count >= size && skp < _this10.max_num)) {
                    _context6.next = 15;
                    break;
                  }

                  _context6.next = 9;
                  return _this10.call_api(action, cls, mergeDeep({
                    options: {
                      num: size,
                      skp: skp
                    }
                  }, params), options);

                case 9:
                  records = _context6.sent;
                  count = records.length;
                  skp += count;

                  if (params.per_chunk_fn) {
                    params.per_chunk_fn(records);
                  } else {
                    if (records.length > 0) {
                      if (concat_chunks) {
                        arr = arr.concat(records);
                      } else {
                        arr.push(records);
                      }
                    }
                  }

                  _context6.next = 6;
                  break;

                case 15:
                  resolve(arr);
                  _context6.next = 21;
                  break;

                case 18:
                  _context6.prev = 18;
                  _context6.t0 = _context6["catch"](5);
                  reject(_context6.t0);

                case 21:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee5, null, [[5, 18]]);
        }));

        return function (_x9, _x10) {
          return _ref3.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "query",
    value: function query(cls) {
      var _this11 = this;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params); // Not sure why this used to be params = JSON.parse(JSON.stringify(params))

      var db_map = params.db_map;

      if (typeof db_map == "undefined") {
        db_map = cls.db_map;
      }

      return this.load_chunks("API_DoQuery", cls, params, {
        data_fn: function data_fn(text) {
          return _this11.map_xml_objs(cls, text, db_map);
        }
      });
    }
  }, {
    key: "query_ex_str",
    value: function query_ex_str(cls, val, key) {
      return "{".concat(cls.fid(key), ".EX.'").concat(encode_html(val), "'}");
    }
  }, {
    key: "build_query",
    value: function build_query(cls, conds) {
      var _this12 = this;

      var jointer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'AND';

      if (typeof conds == "string") {
        return conds;
      } else {
        return forMap(conds, function (val, key) {
          if (Array.isArray(val) && val.length > 0) {
            return '(' + forMap(val, function (val_item) {
              return _this12.query_ex_str(cls, val_item, key);
            }).join('OR') + ')';
          } else {
            return _this12.query_ex_str(cls, val, key);
          }
        }).join(jointer);
      }
    }
  }, {
    key: "save",
    value: function save(obj) {
      var _this13 = this;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      var objs = obj;
      if (typeof objs.length == "undefined") objs = [objs];
      var cls = objs[0].constructor;
      params.clist = this.clist(this.writable_map(cls.db_map, params));
      var size = cls.save_chunk_size ? cls.save_chunk_size : this.save_chunk_size;
      return new Promise( /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(resolve, reject) {
          var _loop2, i;

          return regeneratorRuntime.wrap(function _callee6$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _context8.prev = 0;
                  _loop2 = /*#__PURE__*/regeneratorRuntime.mark(function _loop2(i) {
                    var end, chunk;
                    return regeneratorRuntime.wrap(function _loop2$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            end = i + size;

                            if (end > objs.length + 1) {
                              end = objs.length + 1;
                            }

                            chunk = objs.slice(i, end);
                            params.records_csv = _this13.objs_to_csv(chunk, cls.db_map, params);
                            _context7.next = 6;
                            return _this13.call_api("API_ImportFromCSV", cls, params, {
                              data_fn: function data_fn(text) {
                                var rid_3 = cls.fid("rid") == "3";
                                var xml = new DOMParser().parseFromString(text);
                                forEach(xpath.select("//rid", xml), function (node, i) {
                                  if (rid_3) {
                                    chunk[i].rid = node.textContent;
                                  } else {
                                    chunk[i].rid_3 = node.textContent;
                                  }
                                });
                                forEach(xpath.select("//fields", xml), function (node, i) {
                                  _this13.map_saved_obj(chunk[i], node);
                                });

                                if (params.per_chunk_fn) {
                                  params.per_chunk_fn(chunk);
                                }
                              }
                            });

                          case 6:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _loop2);
                  });
                  i = 0;

                case 3:
                  if (!(i < objs.length)) {
                    _context8.next = 8;
                    break;
                  }

                  return _context8.delegateYield(_loop2(i), "t0", 5);

                case 5:
                  i += size;
                  _context8.next = 3;
                  break;

                case 8:
                  resolve();
                  _context8.next = 14;
                  break;

                case 11:
                  _context8.prev = 11;
                  _context8.t1 = _context8["catch"](0);
                  reject(_context8.t1);

                case 14:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee6, null, [[0, 11]]);
        }));

        return function (_x11, _x12) {
          return _ref4.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "query_delete",
    value: function query_delete(cls) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);

      if (!params.query) {
        throw new Error('You have to provide a query for query_delete!');
      }

      return this.call_api("API_PurgeRecords", cls, params, {
        response_fn: function response_fn(text) {
          return extract_xml_values(text, ["num_records_deleted"])[0];
        }
      });
    }
  }, {
    key: "destroy",
    value: function destroy(obj) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      var objs = obj;
      if (typeof objs.length == "undefined") objs = [objs];
      var cls = objs[0].constructor;
      params.query = this.build_match_objs_query(cls, objs, ["rid"], ["rid"]);
      return this.query_delete(cls, params).then(function () {
        forEach(objs, function (o) {
          o.rid = undefined;
          o.is_deleted = true;
        });
      });
    }
  }, {
    key: "authenticate",
    value: function authenticate() {
      var cls_or_url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.realmhost_main_url;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_Authenticate", cls_or_url, params);
    }
  }, {
    key: "get_schema",
    value: function get_schema() {
      var cls_or_url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.application_url;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      var opt = {};

      if (typeof cls_or_url === 'function' && cls_or_url.url() === this.application_url || cls_or_url === this.application_url) {
        opt.data_fn = function (text) {
          var xml = new DOMParser().parseFromString(text);
          return xpath.select("//chdbid", xml).map(function (node) {
            return {
              alias: node.attributes[0].value,
              dbid: node.firstChild.data
            };
          });
        };
      }

      return this.call_api("API_GetSchema", cls_or_url, params, opt);
    }
  }, {
    key: "run_import",
    value: function run_import(cls_or_url) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_RunImport", cls_or_url, params);
    }
  }, {
    key: "copy_master_detail",
    value: function copy_master_detail(cls_or_url) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_CopyMasterDetail", cls_or_url, params);
    }
  }, {
    key: "upload_file",
    value: function upload_file(cls_or_url) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_UploadFile", cls_or_url, params, {
        data_fn: function data_fn(text) {
          return extract_xml_values(text, ["url"])[0];
        }
      });
    }
  }, {
    key: "make_field_param",
    value: function make_field_param(m, obj) {
      var field = {
        attrs: {
          fid: m.fid
        },
        value: obj[m.name]
      };

      if (isObject(obj[m.name])) {
        field.value = obj[m.name].value;
        field.attrs = _objectSpread2(_objectSpread2({}, field.attrs), obj[m.name].attrs);
      }

      return field;
    }
  }, {
    key: "add_record",
    value: function add_record(obj) {
      var _this14 = this;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      var cls = obj.constructor;

      if (!params.fields) {
        params.fields = [];
        forEach(this.writable_map(cls.db_map), function (m) {
          if (m.name != "rid" && typeof obj[m.name] != "undefined") {
            params.fields.push(_this14.make_field_param(m, obj));
          }
        });
      }

      params.clist = "";
      return this.call_api("API_AddRecord", cls, params, {
        data_fn: function data_fn(text) {
          var res = extract_xml_values(text, ["update_id", 'rid']);
          var rid_3 = obj.constructor.fid("rid") == "3";

          if (rid_3) {
            obj.rid = res[1];
          } else {
            obj.rid_3 = res[1];
          }

          return res[0];
        }
      });
    }
  }, {
    key: "edit_record",
    value: function edit_record(obj) {
      var _this15 = this;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      var cls = obj.constructor;

      if (!params.fields) {
        params.fields = [];
        forEach(this.writable_map(cls.db_map), function (m) {
          if (m.name == "rid") {
            if (m.fid == "3") {
              params.rid = obj.rid;
            } else {
              params.key = obj.rid;
            }
          } else if (typeof obj[m.name] != "undefined") {
            params.fields.push(_this15.make_field_param(m, obj));
          }
        });
      }

      params.clist = "";
      return this.call_api("API_EditRecord", cls, params, {
        data_fn: function data_fn(text) {
          return extract_xml_values(text, ["update_id"])[0];
        }
      });
    }
  }, {
    key: "get_users",
    value: function get_users() {
      var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.application_url;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_UserRoles", cls, params, {
        data_fn: function data_fn(text) {
          var users = [];
          var xml = new DOMParser().parseFromString(text);
          forEach(xpath.select("//user", xml), function (node) {
            var user = {
              roles: []
            };
            forEach(node.attributes, function (attr) {
              user[attr.name] = attr.value;
            });
            xml_each_child(node, function (tag) {
              if (tag.localName == 'roles') {
                forEach(xpath.select("//role", tag), function (role) {
                  user.roles.push(xml_child_tags(role));
                });
              } else {
                user[tag.localName] = tag.textContent;
              }
            });
            users.push(user);
          });
          return users;
        }
      });
    }
  }, {
    key: "export_users_csv",
    value: function export_users_csv() {
      var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.application_url;
      var username = arguments.length > 1 ? arguments[1] : undefined;
      var password = arguments.length > 2 ? arguments[2] : undefined;
      var url = cls + '?a=QBI_ExportUsers';

      if (username && password) {
        url = url + '&username=' + username + '&password=' + password;
      }

      return axios({
        url: url,
        method: 'get',
        responseType: 'text'
      });
    }
  }, {
    key: "delete_file",
    value: function delete_file(obj, field) {
      var cls = obj.constructor;
      var fid = this.fid(cls, field);
      return axios({
        url: cls.url() + '?act=API_EditRecord&rid=' + obj.rid + '&_fid_' + fid + '=&delfile_fid_' + fid + '=1&apptoken=' + this.apptoken + '&usertoken=' + this.usertoken,
        method: 'get',
        responseType: 'text'
      });
    }
  }, {
    key: "add_user_role",
    value: function add_user_role() {
      var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.application_url;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_AddUserToRole", cls, params);
    }
  }, {
    key: "get_user_roles",
    value: function get_user_roles() {
      var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.application_url;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_GetUserRole", cls, params, {
        data_fn: function data_fn(text) {
          var roles = [];
          var xml = new DOMParser().parseFromString(text);
          forEach(xpath.select("//role", xml), function (node) {
            roles.push(xml_child_tags(node));
          });
          return roles;
        }
      });
    }
  }, {
    key: "get_user_info",
    value: function get_user_info() {
      var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.realmhost_main_url;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_GetUserInfo", cls, params, {
        data_fn: function data_fn(text) {
          var xml = new DOMParser().parseFromString(text);
          var node = xpath.select1("//user", xml);
          var user = xml_attrs(node);
          forEach(xml_child_tags(node), function (val, key) {
            return user[key] = val;
          });
          return user;
        }
      });
    }
  }, {
    key: "change_user_role",
    value: function change_user_role() {
      var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.application_url;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_ChangeUserRole", cls, params);
    }
  }, {
    key: "add_user",
    value: function add_user() {
      var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.application_url;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_ProvisionUser", cls, params, {
        data_fn: function data_fn(text) {
          return extract_xml_values(text, ["user_id"])[0];
        }
      });
    }
  }, {
    key: "get",
    value: function get(cls) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      params.jsa = "1";
      return this.load_chunks("API_GenResultsTable", cls, params, {
        script_response: true
      });
    }
  }, {
    key: "objs_to_csv",
    value: function objs_to_csv(objs, db_map) {
      var _this16 = this;

      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      params = mergeDeep({}, params);
      return forMap(objs, function (obj) {
        return forMap(_this16.writable_map(db_map, params), function (m) {
          if (typeof obj[m.name] == "undefined" && m.name != "rid" && !_this16.save_undefined_as_empty) {
            throw new Error("Field " + m.name + " is not defined for record " + JSON.stringify(obj) + ". You can either set an empty string to that field or set QBO.save_undefined_as_empty = true globally.");
          } else if (obj[m.name] == null) {
            return "";
          } else {
            return '"' + ("" + obj[m.name]).replace(/"/g, '""') + '"';
          }
        }).join(",");
      }).join("\n");
    }
  }, {
    key: "url_to",
    value: function url_to(obj, mode) {
      var mode_str = "dr";
      if (mode == "edit") mode_str = "er";
      return obj.constructor.url() + "?a=" + mode_str + "&rid=" + obj.rid;
    }
  }, {
    key: "fid",
    value: function fid(thing, name) {
      var cls = thing;
      if (_typeof(thing) == "object") cls = thing.constructor;
      var found = get_obj(cls.db_map, {
        name: name
      });

      if (found) {
        return found.fid;
      } else {
        throw new Error("Cannot find in db_map field name: " + name);
      }
    }
  }, {
    key: "fname",
    value: function fname(thing, fid) {
      var cls = thing;
      if (_typeof(thing) == "object") cls = thing.constructor;
      var found = get_obj(cls.db_map, {
        fid: fid
      });

      if (found) {
        return found.name;
      } else {
        throw new Error("Cannot find in db_map fid: " + fid);
      }
    }
  }, {
    key: "build_match_objs_query",
    value: function build_match_objs_query(cls, objs, fields, obj_fields) {
      if (typeof obj_fields == "undefined") obj_fields = fields;
      return uniq_arr(forMap(objs, function (obj) {
        return "(" + forMap(fields, function (field, i) {
          return "{'" + cls.fid(field) + "'.EX.'" + obj[obj_fields[i]] + "'}";
        }).join("AND") + ")";
      })).join("OR");
    }
  }, {
    key: "build_match_array_query",
    value: function build_match_array_query(cls, arr, field) {
      return uniq_arr(forMap(arr, function (val) {
        return "{'" + cls.fid(field) + "'.EX.'" + val + "'}";
      })).join("OR");
    }
  }, {
    key: "add_form",
    value: function add_form(cls) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      params = mergeDeep({}, params);
      return this.call_api("API_GenAddRecordForm", cls, params, {
        form_response: true
      });
    }
  }, {
    key: "check_db_map",
    value: function check_db_map(cls, db_map) {
      var _this17 = this;

      if (typeof db_map == "undefined") {
        return true;
      }

      var hsh = {};
      var duplicates = [];
      forEach(db_map, function (m) {
        if (!_this17.is_fake_field(m)) {
          if (hsh[m.fid] == true) {
            duplicates.push(m.fid);
          }

          hsh[m.fid] = true;
        }
      });

      if (duplicates.length > 0) {
        throw new Error("".concat(cls.alias, " db_map has duplicate fid ").concat(duplicates.join(", ")));
      } else {
        return true;
      }
    }
  }, {
    key: "table_url",
    value: function table_url(alias) {
      var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.application_url;
      return url + "/(" + alias + ")";
    }
  }, {
    key: "set_current_user",
    value: function set_current_user() {
      var _this18 = this;

      var include_roles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var realm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.realmhost_main_url;
      var cls = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.application_url;
      return this.get_user_info(realm).then(function (user) {
        _this18.current_user = user;

        if (include_roles) {
          return _this18.get_user_roles(cls, {
            userid: user.id
          }).then(function (res) {
            _this18.current_user.roles = res;
          });
        }
      });
    }
  }, {
    key: "record_class_init",
    value: function record_class_init(klass) {
      klass.alias = "";
      klass.QBO = this;
      klass.db_map = [];
      klass.schema_fields = [];
      klass.schema_opt = {};
      klass.records = [];
      klass.query_opt = {};
      klass.save_opt = {};
      klass.load_method = "get";
      klass.model_key = underscorize(klass.name);
      forEach(["query", "get", "build_query", "build_slist", "query_delete", "run_import", "copy_master_detail", "upload_file", "build_match_objs_query", "build_match_array_query", "add_form", "fid", "fname"], function (func_name) {
        klass[func_name] = function () {
          var _klass$QBO;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return (_klass$QBO = klass.QBO)[func_name].apply(_klass$QBO, [klass].concat(args));
        };
      });
      forEach(["save", "destroy", "add_record", "edit_record", "delete_file", "url_to"], function (func_name) {
        klass[func_name] = function () {
          var _klass$QBO2;

          return (_klass$QBO2 = klass.QBO)[func_name].apply(_klass$QBO2, arguments);
        };

        klass.prototype[func_name] = function () {
          var _klass$QBO3;

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return (_klass$QBO3 = klass.QBO)[func_name].apply(_klass$QBO3, [this].concat(args));
        };
      }); // Still use QBO. for "authenticate", "get_users", "add_user_role", "get_user_roles", "get_user_info", "set_current_user"

      klass.url = function () {
        return klass.QBO.table_url(klass.alias);
      };

      klass.update_db_map = function (fid, obj) {
        update_obj(klass.db_map, {
          fid: fid
        }, obj);
      };

      klass.load_records = function () {
        return klass[klass.load_method](klass.query_opt).then(function (arr) {
          klass.records = arr;
        });
      };

      klass.save_records = function () {
        if (klass.records.length == 0) {
          return new Promise(function (resolve) {
            return resolve();
          });
        } else {
          return klass.save(klass.records, klass.save_opt);
        }
      };

      klass.get_record = function (rid) {
        return get_obj(klass.records, {
          rid: rid
        });
      };

      klass.update_record = function (rid, obj) {
        update_obj(klass.records, {
          rid: rid
        }, obj);
      };

      klass.set_schema_fields = function () {
        var update_db_map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return klass.QBO.get_schema(klass, klass.schema_opt).then(function (text) {
          var xml = new DOMParser().parseFromString(text);
          klass.table_label = xpath.select("//name", xml)[0].firstChild.data;
          klass.schema_fields = forMap(xpath.select("//field", xml), function (node) {
            var field = xml_attrs(node);
            xml_each_child(node, function (tag) {
              if (tag.localName == 'choices') {
                field.choices = [];
                xml_each_child(tag, function (node) {
                  var choice = node.textContent;

                  if (!is_blank(choice)) {
                    field.choices.push(choice);
                  }
                });
              } else {
                field[tag.localName] = tag.textContent;
              }
            });
            field.name = underscorize(field.label);

            if (field.field_type == "recordid") {
              field.name = "rid";
            } else if (!is_blank(field.mode == "virtual" || field.mode == "lookup" || parseInt(field.id) < 6)) {
              field.readonly = true;
            }

            field.required = field.required == "1";
            return field;
          });

          if (update_db_map) {
            klass.update_db_map();
          }
        });
      };

      klass.update_db_map = function () {
        klass.db_map = forMap(klass.db_map, function (map) {
          if (map.is_fake == true) {
            return map;
          } else {
            var new_map = {};
            var schema_field = get_obj(klass.schema_fields, {
              id: map.fid
            });

            if (typeof schema_field == "undefined") {
              throw new Error("Field " + map.fid + " doesn't exist in table " + klass.name + ": " + klass.url());
            } else {
              ["field_type", "base_type", "required", "label", "choices", "num_lines", "maxlength", "readonly"].forEach(function (key) {
                if (typeof schema_field[key] != "undefined") {
                  if (key == "choices") {
                    new_map[key] = forMap(schema_field.choices, function (choice) {
                      return {
                        id: choice,
                        name: choice
                      };
                    });
                    new_map[key] = [{
                      id: "",
                      name: ""
                    }].concat(new_map[key]);
                  } else {
                    new_map[key] = schema_field[key];
                  }
                }
              });
            }

            return mergeDeep(new_map, map);
          }
        });
      };

      this.klasses.push(klass);
    }
  }, {
    key: "realmhost_url",
    get: function get() {
      return this.application_url.split("/db/")[0];
    }
  }, {
    key: "realmhost_main_url",
    get: function get() {
      return this.realmhost_url + "/db/main";
    }
  }]);

  return QBOFactory;
}();

var supportedActions$1 = Object.keys(supportedActions);

exports.QBAPIError = QBAPIError;
exports.QBOFactory = QBOFactory;
exports.QuickBaseClient = QuickBaseClient;
exports.supportedActions = supportedActions$1;
exports.utilities = utilities;
