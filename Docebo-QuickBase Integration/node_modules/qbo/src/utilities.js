import xpath from "xpath";
import xmldom from 'xmldom';

export const DOMParser = xmldom.DOMParser;

export const extract_xml_values = (text, names) => {
    let xml = new DOMParser().parseFromString(text);
    return forMap(names, name => {
        let node = xpath.select1("//" + name, xml);
        if (!is_blank(node)) {
            return node.textContent;
        }
    });
};

export const xml_attrs = node => {
    let obj = {};
    forEach(node.attributes, attr => {
        if (typeof (attr.name) != 'undefined') {
            obj[attr.name] = attr.value;
        }
    });
    return obj;
};

export const xml_child_tags = node => {
    let obj = {};
    xml_each_child(node, prop => {
        obj[prop.localName] = prop.textContent;
    });
    return obj;
};

export const xml_each_child = (node, fn) => {
    forEach(node.childNodes, child => {
        if (child.nodeType == 1) {
            fn(child);
        }
    });
};

export const trim = s => s.trim();

export const isObject = o => typeof o === 'object';

export const isEmptyObject = o => {
    for (const key in o) {
        if (o.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
};

export const isFunction = f => typeof f === 'function';

export const isString = s => typeof s === 'string';

export const isBlankString = s => isString(s) && trim(s) === '';

export const isNonBlankString = s => isString(s) && trim(s) !== '';

export const isIntegerString = s => (typeof s === 'number' || typeof s === 'string') && parseInt(s) + '' === s + '';

export const isTrueOrFalse = s => s === 'true' || s === 'false';

export const parseIntString = v => parseInt(v).toString();

export const isZeroOrOne = v => [0, 1].includes(parseInt(v));

export const getProperty = (object, propertyName, {defaultValue, validate, normalize} = {}) => {
    if (!isObject(object) || isBlankString(propertyName)) {
        return undefined;
    }
    if (object[propertyName] === undefined) {
        return defaultValue;
    }
    let value = object[propertyName];
    if (validate && isFunction(validate)) {
        if (validate(value) !== true) {
            return defaultValue;
        }
    }
    if (normalize && isFunction(normalize)) {
        value = normalize(value);
    }
    return value;
};

export const cdata = s => `<![CDATA[${s}]]>`;

export const EN_MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

export const EN_MONTHS_LONG = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

export const EN_WEEKDAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

export const EN_WEEKDAYS_LONG = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

export const underscorize = str => {
    let result = str.toLowerCase().replace(/[^A-Za-z0-9]/g, "_");
    if (result.match(/^\d/) != null) {
        result = "n" + result;
    }
    return result;
};

export const isHash = item => {
    return (item && typeof item === 'object' && !Array.isArray(item));
};

export const mergeDeep = (target, ...sources) => {
    if (!sources.length) return target;
    const source = sources.shift();

    if (isHash(target) && isHash(source)) {
        for (const key in source) {
            if (isHash(source[key])) {
                if (!target[key]) {
                    target[key] = {};
                }
                mergeDeep(target[key], source[key]);
            } else {
                target[key] = source[key];
            }
        }
    }
    return mergeDeep(target, ...sources);
};

export const addCommas = nStr => {
    nStr += '';
    let x = nStr.split('.');
    let x1 = x[0];
    let x2 = x.length > 1 ? '.' + x[1] : '';
    let rgx = /(\d+)(\d{3})/;
    while (rgx.test(x1)) {
        x1 = x1.replace(rgx, '$1' + ',' + '$2');
    }
    return x1 + x2;
};

export function parseNumber(str) {
    if (typeof (str) === "number") {
        return str;
    }

    str = parseNumberStr(str)
    if (str.match('.')) {
        return parseFloat(str);
    } else {
        return parseInt(str)
    }
}

export function parseNumberStr(str) {
    if (typeof (str) !== "string") {
        return '';
    }
    return str.replace(/,/g, "").replace(/[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6]/, "").replace(/%/, "");
}

export const getURLParameter = (name, url) => {
    let qry = location.href.split("?")[1];
    if (typeof (url) != "undefined") {
        qry = url.split("?")[1];
    }
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    let regex = new RegExp("(^|&)" + name + "=([^&#]*)"),
        results = regex.exec(qry);
    return results === null ? "" : decodeURIComponent(results[2].replace(/\+/g, " "));
};

export const is_blank = str => {
    return typeof (str) == "undefined" || str == "" || str == null || (Object.prototype.toString.call(str) === '[object Array]' && str.length == 0);
};


export const is_true = str => {
    let n_str = ("" + str).toLowerCase();
    return n_str == "yes" || n_str == "1" || n_str == "true";
};

export const is_false = str => {
    let n_str = ("" + str).toLowerCase();
    return n_str == "no" || n_str == "0" || n_str == "false";
};

export const to_date = (str) => {
    let strs = str.split("-");
    if (strs.length == 3) {
        let nums = forMap(strs, s => {
            return parseInt(s, 10);
        });
        if (isNaN(nums[0])) {
            nums[0] = EN_MONTHS.indexOf(strs[0]);
        } else {
            nums[0]--;
        }
        return new Date(nums[2], nums[0], nums[1]);
    } else {
        return new Date(parseInt(str, 10));
    }
};

export const to_bool = str => {
    return is_true(str);
};

export const to_arr = (str, delimiter = ",") => {
    if (str == "") {
        return [];
    } else {
        return forMap(str.split(delimiter), s => {
            return s.trim();
        });
    }
};

export const to_currency = (num, decimal = 2, sign = "$") => {
    if (typeof (num) != "number") {
        num = parseNumber(num);
    }
    return sign + addCommas(num.toFixed(decimal));
};

export const to_percent = (num, decimal = 0) => {
    if (typeof (num) != "number") {
        num = parseNumber(num);
    }
    num = num.toFixed(decimal);
    return "" + num + "%";
};

export const validate_email = email => {
    let re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(String(email).toLowerCase());
};

export const validate_url = val => {
    return /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(val);
};

export function forEach(input, fn) {
    if (Array.isArray(input)) {
        input.forEach((val, key) => {
            fn(val, key);
        });
    } else {
        Object.keys(input).forEach(key => {
            fn(input[key], key);
        });
    }
}

export function forMap(input, fn) {
    if (Array.isArray(input)) {
        return input.map((val, key) => {
            return fn(val, key);
        });
    } else {
        let arr = [];
        Object.keys(input).forEach(key => {
            arr.push(fn(input[key], key));
        });
        return arr;
    }
}

export function sort_by(input, attr) {
    input.sort(function (a, b) {
        let str_a = a[attr].toLowerCase();
        let str_b = b[attr].toLowerCase();
        if (str_a < str_b)
            return -1;
        if (str_a > str_b)
            return 1;
        return 0;
    });
}

export function get_obj(input, conds, opt) {
    validate_undefined_attr(conds, "get_obj");
    return input.find(item => {
        let found_false = Object.keys(conds).find(key => {
            return !match_x_y(item[key], conds[key], opt);
        });
        return typeof (found_false) == "undefined";
    });
}

export function get_objs(input, conds, opt) {
    validate_undefined_attr(conds, "get_objs");
    return input.filter(item => {
        let found_false = Object.keys(conds).find(key => {
            return !match_x_y(item[key], conds[key], opt);
        });
        return typeof (found_false) == "undefined";
    });
}

function match_x_y(x, y, opt = {}) {
    let a = "" + x;
    let b = "" + y;

    if (opt.case_insensitive == true) {
        a = a.toLowerCase();
        b = b.toLowerCase();
    }

    if (opt.sub_match == true) {
        return a.match(b) != null;
    } else {
        return a == b;
    }
}

function validate_undefined_attr(conds, fn_name) {
    forEach(conds, (val, key) => {
        if (typeof (val) == "undefined") {
            let msg = key + " is undefined in " + fn_name + ": " + JSON.stringify(conds);
            throw new Error(msg);
        }
    });
}

export function update_obj(input, conds, attrs) {
    let obj = get_obj(input, conds);
    forEach(attrs, (v, attr) => {
        obj[attr] = v;
    });
}

export function update_objs(input, conds, attrs) {
    let objs = get_objs(input, conds);
    forEach(objs, obj => {
        forEach(attrs, (attr, v) => {
            obj[attr] = v;
        });
    });
}

export function uniq_arr(input) {
    return [...new Set(input)];
}

export function pad_0(input, size) {
    let s = input + "";
    while (s.length < size) s = "0" + s;
    return s;
}

export function to_ymd(input, delimiter) {
    if (isNaN(input.getTime())) {
        return "";
    } else {
        if (typeof (delimiter) == "undefined") {
            delimiter = "-";
        }
        return [input.getFullYear(), pad_0(input.getMonth() + 1, 2), pad_0(input.getDate(), 2)].join(delimiter);
    }
}

export function to_mdy(input, delimiter) {
    if (isNaN(input.getTime())) {
        return "";
    } else {
        if (typeof (delimiter) == "undefined") {
            delimiter = "-";
        }
        return [pad_0(input.getMonth() + 1, 2), pad_0(input.getDate(), 2), input.getFullYear()].join(delimiter);
    }
}

export function to_dmy(input, delimiter) {
    if (isNaN(input.getTime())) {
        return "";
    } else {
        if (typeof (delimiter) == "undefined") {
            delimiter = "-";
        }
        return [pad_0(input.getDate(), 2), pad_0(input.getMonth() + 1, 2), input.getFullYear()].join(delimiter);
    }
}

export function to_md(input) {
    if (isNaN(input.getTime())) {
        return "";
    } else {
        return EN_MONTHS[input.getMonth()] + " " + input.getDate();
    }
}

export function to_timestamp(input, delimiter) {
    if (isNaN(input.getTime())) {
        return "";
    } else {
        return to_ymd(input, delimiter) + " " + pad_0(input.getHours(), 2) + ":" + pad_0(input.getMinutes(), 2) + ":" + pad_0(input.getSeconds(), 2);
    }
}

export function encode_html(input) {
    return ('' + input).replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}

export function decode_html(input) {
    return ('' + input).replace(/&apos;/g, "'")
        .replace(/&quot;/g, '"')
        .replace(/&gt;/g, '>')
        .replace(/&lt;/g, '<')
        .replace(/&amp;/g, '&');
}

export function encode_xml(input) {
    return ('' + input).replace(/[<>&'"]/g, function (c) {
        switch (c) {
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '&':
                return '&amp;';
            case '\'':
                return '&apos;';
            case '"':
                return '&quot;';
        }
    });
}
