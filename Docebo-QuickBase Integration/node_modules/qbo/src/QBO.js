import xpath from 'xpath';
import {supportedActions} from "./supportedActions";
import QuickBaseClient from './QuickBaseClient';
import QBAPIError from './QBAPIError';
import {
    extract_xml_values, xml_child_tags, xml_attrs,
    xml_each_child, DOMParser, is_true, parseNumber,
    underscorize, is_blank, mergeDeep, forEach, forMap,
    uniq_arr, encode_html, update_obj, get_obj, encode_xml, isObject,
} from './utilities'
import axios from "axios";

const default_converts = {
    checkbox: is_true,
    duration: parseNumber,
    number: parseNumber,
    currency: parseNumber,
    percent: parseNumber,
};

const default_max_num = 4294967296;

export default class QBOFactory {
    constructor({application_url = null} = {}) {
        this.apptoken = "";
        this.usertoken = "";
        this.application_url = application_url;
        if (!this.application_url && typeof window !== 'undefined') {
            this.application_url = window.location.origin + window.location.pathname;
        }
        this.proxy_url = "";
        this.klasses = [];
        this.auto_clist_output = false;
        this.save_undefined_as_empty = false;
        this.max_num = default_max_num;
        this.chunk_size = default_max_num;
        this.save_chunk_size = default_max_num;
        this.concat_chunks = true;
        this.loggers_debuggers = {}; // {log_request_opt: opt => console.log(opt)}
        this.current_user = null;

        forEach(supportedActions, (val, action) => {
            this[action] = (cls, params = {}) => {
                let default_params = {};
                let db_map = params.db_map;
                if (typeof (db_map) == "undefined") {
                    db_map = cls.db_map;
                }
                if (this.check_db_map(cls, db_map)) {
                    if (typeof (cls) == "string") {
                        default_params = mergeDeep({}, default_params, {
                            options: {
                                num: this.max_num,
                                skp: "0",
                                sortorder: "A"
                            },
                            apptoken: this.apptoken,
                            usertoken: this.usertoken,
                            ticket: this.ticket,
                            username: this.username,
                            password: this.password,
                            proxy_url: this.proxy_url,
                        });
                    } else {
                        default_params = mergeDeep({}, default_params, {
                            clist: this.clist(db_map),
                            options: {
                                num: this.max_num,
                                skp: "0",
                                sortorder: "A"
                            },
                            apptoken: (cls.apptoken ? cls.apptoken : this.apptoken),
                            usertoken: (cls.usertoken ? cls.usertoken : this.usertoken),
                            ticket: (cls.ticket ? cls.ticket : this.ticket),
                            username: (cls.username ? cls.username : this.username),
                            password: (cls.password ? cls.password : this.password),
                            proxy_url: (cls.proxy_url ? cls.proxy_url : this.proxy_url),
                            auto_clist_output: (cls.auto_clist_output ? cls.auto_clist_output : this.auto_clist_output),
                        });

                        if (default_params.auto_clist_output) {
                            default_params.clist_output = this.clist(cls.db_map);
                        }
                    }
                    params = mergeDeep({}, default_params, params);
                    params.options = this.options_to_string(params.options);
                    let config = {
                        apptoken: params.apptoken,
                        usertoken: params.usertoken,
                        ticket: params.ticket,
                        username: params.username,
                        password: params.password,
                        settings: {proxy_url: params.proxy_url}
                    };
                    let client = new QuickBaseClient(config, this.loggers_debuggers);
                    let url = cls;
                    if (typeof (cls) != "string") {
                        url = cls.url();
                    }
                    return client[action](url, params);
                }
            };
        });
    }

    get realmhost_url() {
        return this.application_url.split("/db/")[0];
    }

    get realmhost_main_url() {
        return this.realmhost_url + "/db/main";
    }

    to_file_arr(str) {
        if (str == "") {
            return ["", ""];
        } else {
            let urls = str.split("https://");
            return [urls[0], "https://" + urls[1]];
        }
    }

    to_file_link(str) {
        if (str == "") {
            return "";
        } else {
            let urls = str.split("https://");
            return "<a href='https://" + urls[1] + "' target='_blank'>" + urls[0] + "</a>";
        }
    }

    is_readonly_field(m) {
        if (m.readonly == true) {
            return true;
        } else {
            let name = ["lookup", "formula", "system", "readonly"].find(n => n == m.field_type);
            return typeof (name) != "undefined";
        }
    }

    is_fake_field(m) {
        return m.is_fake == true;
    }

    is_writable_field(m, params = {}) {
        return !this.is_readonly_field(m) && !this.is_fake_field(m) && (is_blank(params.mergeFieldId) || m.name != "rid");
    }

    writable_map(db_map, params) {
        return db_map.filter(m => this.is_writable_field(m, params));
    }

    clist(db_map) {
        return forMap(db_map.filter(m => !this.is_fake_field(m)), m => {
            return m.fid;
        }).join(".");
    }

    map_saved_obj(obj, node) {
        let cls = obj.constructor;
        xml_each_child(node, field => {
            forEach(field.attributes, attr => {
                if (attr.name == "id") {
                    this.assign_and_convert_field(obj, get_obj(cls.db_map, {fid: attr.value}), field.textContent);
                }
            });
        });

        if (typeof (cls.after_load) != "undefined") cls.after_load(obj);
        return obj;
    }

    assign_and_convert_field(obj, map, val) {
        obj[map.name] = val;
        if (map.valueToData) {
            obj[map.name] = map.valueToData(obj[map.name]);
        } else if (typeof (map.convert) == "undefined") {
            if (default_converts[map.field_type]) {
                obj[map.name] = default_converts[map.field_type](obj[map.name]);
            }
        } else {
            let fn_name = map.convert.name;
            if (fn_name == "parseInt" || fn_name == "parseFloat") obj[map.name] = obj[map.name].replace(/,/g, "");
            obj[map.name] = map.convert(obj[map.name]);
        }
    }

    async throw_deleted_field_error(cls) {
        const fids = [];
        await cls.set_schema_fields(false);
        cls.db_map.forEach(m => {
            const found = cls.schema_fields.find(f => f.id === m.fid);
            if (!found) {
                fids.push(m.fid);
            }
        });
        throw new Error(`Field ID ${fids.join(', ')} was deleted from table ${cls.table_label} which the code uses. Please contact the programmer.`);
    }

    map_obj(cls, data_arr, db_map) {
        let obj = new cls();
        forEach(db_map, (map, i) => {
            this.assign_and_convert_field(obj, map, data_arr[i]);
        });

        if (typeof (cls.after_load) != "undefined") cls.after_load(obj);
        return obj;
    }

    async map_objs(cls, data_arrs, db_map) {
        db_map = db_map.filter(m => {
            return m.is_fake != true;
        });

        if (data_arrs[0] && data_arrs[0].length != db_map.length) {
            await this.throw_deleted_field_error(cls);
        }

        return forMap(data_arrs, a => {
            return this.map_obj(cls, a, db_map);
        });
    }

    async map_xml_objs(cls, text, db_map) {
        let records = [];
        if (typeof (db_map) == "undefined") {
            db_map = cls.db_map;
        }
        db_map = db_map.filter(m => {
            return m.is_fake != true;
        });

        let xml = new DOMParser().parseFromString(text);
        let nodes = xpath.select("//record", xml);

        for (const i in nodes) {
            let field_count = 0;
            let data_arr = [];
            xml_each_child(nodes[i], field => {
                if (field.localName != "update_id") {
                    field_count++;
                    data_arr.push(field.textContent);
                }
            });

            if (field_count != db_map.length) {
                await this.throw_deleted_field_error(cls);
            }

            records.push(this.map_obj(cls, data_arr, db_map));
        }

        return records;
    }

    options_to_string(options) {
        if (typeof (options) == "undefined") {
            return undefined;
        }
        return "skp-" + options.skp + ".sortorder-" + options.sortorder + ".num-" + options.num;
    }

    build_slist(cls, arr) {
        return arr.map(name => this.fid(cls, name)).join('.');
    }

    call_api(action, cls, params = {}, options = {}) {
        if (typeof (params.query) != "undefined") {
            params.query = this.build_query(cls, params.query)
        }

        if (typeof params.slist != 'undefined' && Array.isArray(params.slist)) {
            params.slist = this.build_slist(cls, params.slist);
        }

        let promise = new Promise((resolve, reject) => {
            this[action](cls, params).then(async text => {
                if (options.script_response == true && text.match('qdbapi') === null) {
                    try {
                        let {data, err_str} = this.extract_script_response(text);

                        if (typeof (err_str) == "undefined") {
                            resolve(await this.map_objs(cls, data, cls.db_map));
                        } else {
                            reject(new QBAPIError(err_str));
                        }
                    } catch (error) {
                        reject(error);
                    }
                } else if (options.form_response == true) {
                    resolve(text);
                } else {
                    let [errcode, errtext, errdetail] = extract_xml_values(text, ["errcode", "errtext", "errdetail"])

                    if (errcode == "0") {
                        if (typeof (options.response_fn) != "undefined") {
                            resolve(options.response_fn(text));
                        } else if (typeof (options.data_fn) != "undefined") {
                            resolve(await options.data_fn(text));
                        } else {
                            resolve(text);
                        }
                    } else {
                        reject(new QBAPIError(errtext + ": " + errdetail));
                    }
                }
            }, textStatus => {
                reject(new QBAPIError(textStatus));
            });
        });
        return promise;
    }

    extract_script_response(text) {
        let res = {};
        (0, eval)(text);

        if (text.match("document\\.write")) {
            res.err_str = "ERORR: " + text.match(/<div id=\\x22response_errormsg\\x22>(.*?)<\\\/div>/)[1];
        } else {
            (0, eval)(text);
            if (typeof (qdb_data) != "undefined") {
                res.data = qdb_data;
            }
        }

        return res;
    }

    load_chunks(action, cls, params = {}, options) {
        return new Promise(async (resolve, reject) => {
            let arr = [];
            const concat_chunks = typeof cls.concat_chunks === 'undefined' ? this.concat_chunks : cls.concat_chunks;
            const size = cls.chunk_size ? cls.chunk_size : this.chunk_size;
            let skp = 0;
            let count = size;

            try {
                while (count >= size && skp < this.max_num) {
                    const records = await this.call_api(action, cls, mergeDeep({
                        options: {
                            num: size,
                            skp: skp
                        }
                    }, params), options);
                    count = records.length;
                    skp += count;

                    if (params.per_chunk_fn) {
                        params.per_chunk_fn(records);
                    } else {
                        if (records.length > 0) {
                            if (concat_chunks) {
                                arr = arr.concat(records);
                            } else {
                                arr.push(records);
                            }
                        }
                    }
                }
                resolve(arr);
            } catch (error) {
                reject(error);
            }
        });
    }

    query(cls, params = {}) {
        params = mergeDeep({}, params); // Not sure why this used to be params = JSON.parse(JSON.stringify(params))
        let db_map = params.db_map;
        if (typeof (db_map) == "undefined") {
            db_map = cls.db_map;
        }
        return this.load_chunks("API_DoQuery", cls, params, {
            data_fn: text => {
                return this.map_xml_objs(cls, text, db_map);
            }
        });
    }

    query_ex_str(cls, val, key) {
        return `{${cls.fid(key)}.EX.'${encode_html(val)}'}`;
    }

    build_query(cls, conds, jointer = 'AND') {
        if (typeof (conds) == "string") {
            return conds;
        } else {
            return forMap(conds, (val, key) => {
                if (Array.isArray(val) && val.length > 0) {
                    return '(' + forMap(val, val_item => {
                        return this.query_ex_str(cls, val_item, key);
                    }).join('OR') + ')';
                } else {
                    return this.query_ex_str(cls, val, key);
                }
            }).join(jointer);
        }
    }

    save(obj, params = {}) {
        params = mergeDeep({}, params);
        let objs = obj;
        if (typeof (objs.length) == "undefined") objs = [objs];
        let cls = objs[0].constructor;
        params.clist = this.clist(this.writable_map(cls.db_map, params));

        const size = cls.save_chunk_size ? cls.save_chunk_size : this.save_chunk_size;
        return new Promise(async (resolve, reject) => {
            try {
                for (let i = 0; i < objs.length; i += size) {
                    let end = i + size;
                    if(end > objs.length + 1){
                        end = objs.length + 1;
                    }
                    const chunk = objs.slice(i, end);

                    params.records_csv = this.objs_to_csv(chunk, cls.db_map, params);

                    await this.call_api("API_ImportFromCSV", cls, params, {
                        data_fn: text => {
                            let rid_3 = cls.fid("rid") == "3";

                            let xml = new DOMParser().parseFromString(text);
                            forEach(xpath.select("//rid", xml), (node, i) => {
                                if (rid_3) {
                                    chunk[i].rid = node.textContent;
                                } else {
                                    chunk[i].rid_3 = node.textContent;
                                }
                            });

                            forEach(xpath.select("//fields", xml), (node, i) => {
                                this.map_saved_obj(chunk[i], node);
                            });

                            if (params.per_chunk_fn) {
                                params.per_chunk_fn(chunk);
                            }
                        }
                    });
                }
                resolve();
            } catch (error) {
                reject(error);
            }
        });
    }

    query_delete(cls, params = {}) {
        params = mergeDeep({}, params);
        if (!params.query) {
            throw new Error('You have to provide a query for query_delete!');
        }
        return this.call_api("API_PurgeRecords", cls, params, {
            response_fn: text => extract_xml_values(text, ["num_records_deleted"])[0]
        });
    }

    destroy(obj, params = {}) {
        params = mergeDeep({}, params);
        let objs = obj;
        if (typeof (objs.length) == "undefined") objs = [objs];
        let cls = objs[0].constructor;
        params.query = this.build_match_objs_query(cls, objs, ["rid"], ["rid"]);
        return this.query_delete(cls, params).then(() => {
            forEach(objs, o => {
                o.rid = undefined;
                o.is_deleted = true;
            });
        });
    }

    authenticate(cls_or_url = this.realmhost_main_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_Authenticate", cls_or_url, params);
    }

    get_schema(cls_or_url = this.application_url, params = {}) {
        params = mergeDeep({}, params);
        let opt = {};
        if (typeof cls_or_url === 'function' && cls_or_url.url() === this.application_url || cls_or_url === this.application_url) {
            opt.data_fn = text => {
                let xml = new DOMParser().parseFromString(text);
                return xpath.select("//chdbid", xml).map(node => {
                    return {alias: node.attributes[0].value, dbid: node.firstChild.data};
                });
            }
        }
        return this.call_api("API_GetSchema", cls_or_url, params, opt);
    }

    run_import(cls_or_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_RunImport", cls_or_url, params);
    }

    copy_master_detail(cls_or_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_CopyMasterDetail", cls_or_url, params);
    }

    upload_file(cls_or_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_UploadFile", cls_or_url, params, {
            data_fn: text => extract_xml_values(text, ["url"])[0]
        });
    }

    make_field_param(m, obj) {
        let field = {attrs: {fid: m.fid}, value: obj[m.name]};
        if (isObject(obj[m.name])) {
            field.value = obj[m.name].value;
            field.attrs = {...field.attrs, ...obj[m.name].attrs}
        }
        return field;
    }

    add_record(obj, params = {}) {
        params = mergeDeep({}, params);
        let cls = obj.constructor;

        if (!params.fields) {
            params.fields = [];
            forEach(this.writable_map(cls.db_map), m => {
                if (m.name != "rid" && typeof (obj[m.name]) != "undefined") {
                    params.fields.push(this.make_field_param(m, obj));
                }
            });
        }

        params.clist = "";

        return this.call_api("API_AddRecord", cls, params, {
            data_fn: text => {
                const res = extract_xml_values(text, ["update_id", 'rid']);
                let rid_3 = obj.constructor.fid("rid") == "3";

                if (rid_3) {
                    obj.rid = res[1];
                } else {
                    obj.rid_3 = res[1];
                }

                return res[0];
            }
        });
    }

    edit_record(obj, params = {}) {
        params = mergeDeep({}, params);
        let cls = obj.constructor;

        if (!params.fields) {
            params.fields = [];
            forEach(this.writable_map(cls.db_map), m => {
                if (m.name == "rid") {
                    if (m.fid == "3") {
                        params.rid = obj.rid;
                    } else {
                        params.key = obj.rid;
                    }
                } else if (typeof (obj[m.name]) != "undefined") {
                    params.fields.push(this.make_field_param(m, obj));
                }
            });
        }

        params.clist = "";
        return this.call_api("API_EditRecord", cls, params, {
            data_fn: text => extract_xml_values(text, ["update_id"])[0]
        });
    }

    get_users(cls = this.application_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_UserRoles", cls, params, {
            data_fn: text => {
                let users = [];
                let xml = new DOMParser().parseFromString(text);
                forEach(xpath.select("//user", xml), node => {
                    let user = {roles: []};

                    forEach(node.attributes, attr => {
                        user[attr.name] = attr.value;
                    });

                    xml_each_child(node, tag => {
                        if (tag.localName == 'roles') {
                            forEach(xpath.select("//role", tag), role => {
                                user.roles.push(xml_child_tags(role));
                            });
                        } else {
                            user[tag.localName] = tag.textContent;
                        }
                    });
                    users.push(user);
                });
                return users;
            }
        });
    }

    export_users_csv(cls = this.application_url, username, password) {
        let url = cls + '?a=QBI_ExportUsers';
        if (username && password) {
            url = url + '&username=' + username + '&password=' + password;
        }
        return axios({
            url,
            method: 'get',
            responseType: 'text',
        });
    }

    delete_file(obj, field) {
        const cls = obj.constructor;
        const fid = this.fid(cls, field);
        return axios({
            url: cls.url() + '?act=API_EditRecord&rid=' + obj.rid + '&_fid_' + fid + '=&delfile_fid_' + fid + '=1&apptoken=' + this.apptoken + '&usertoken=' + this.usertoken,
            method: 'get',
            responseType: 'text',
        });
    }

    add_user_role(cls = this.application_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_AddUserToRole", cls, params);
    }

    get_user_roles(cls = this.application_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_GetUserRole", cls, params, {
            data_fn: text => {
                let roles = [];
                let xml = new DOMParser().parseFromString(text);
                forEach(xpath.select("//role", xml), node => {
                    roles.push(xml_child_tags(node));
                });
                return roles;
            }
        });
    }

    get_user_info(cls = this.realmhost_main_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_GetUserInfo", cls, params, {
            data_fn: text => {
                let xml = new DOMParser().parseFromString(text);
                let node = xpath.select1("//user", xml);
                let user = xml_attrs(node);
                forEach(xml_child_tags(node), (val, key) => user[key] = val);
                return user;
            }
        });
    }

    change_user_role(cls = this.application_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_ChangeUserRole", cls, params);
    }

    add_user(cls = this.application_url, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_ProvisionUser", cls, params, {
            data_fn: text => extract_xml_values(text, ["user_id"])[0]
        });
    }

    get(cls, params = {}) {
        params = mergeDeep({}, params);
        params.jsa = "1";
        return this.load_chunks("API_GenResultsTable", cls, params, {script_response: true});
    }

    objs_to_csv(objs, db_map, params = {}) {
        params = mergeDeep({}, params);
        return forMap(objs, obj => {
            return forMap(this.writable_map(db_map, params), m => {
                if (typeof (obj[m.name]) == "undefined" && m.name != "rid" && !this.save_undefined_as_empty) {
                    throw new Error("Field " + m.name + " is not defined for record " + JSON.stringify(obj) + ". You can either set an empty string to that field or set QBO.save_undefined_as_empty = true globally.");
                } else if (obj[m.name] == null) {
                    return "";
                } else {
                    return '"' + ("" + obj[m.name]).replace(/"/g, '""') + '"';
                }
            }).join(",");
        }).join("\n");
    }

    url_to(obj, mode) {
        let mode_str = "dr";
        if (mode == "edit") mode_str = "er";
        return obj.constructor.url() + "?a=" + mode_str + "&rid=" + obj.rid;
    }

    fid(thing, name) {
        let cls = thing;
        if (typeof (thing) == "object") cls = thing.constructor;
        const found = get_obj(cls.db_map, {name: name});
        if (found) {
            return found.fid;
        } else {
            throw new Error("Cannot find in db_map field name: " + name);
        }
    }

    fname(thing, fid) {
        let cls = thing;
        if (typeof (thing) == "object") cls = thing.constructor;
        const found = get_obj(cls.db_map, {fid: fid});
        if (found) {
            return found.name;
        } else {
            throw new Error("Cannot find in db_map fid: " + fid);
        }
    }

    build_match_objs_query(cls, objs, fields, obj_fields) {
        if (typeof (obj_fields) == "undefined") obj_fields = fields;
        return uniq_arr(forMap(objs, obj => {
            return "(" + forMap(fields, (field, i) => {
                return "{'" + cls.fid(field) + "'.EX.'" + obj[obj_fields[i]] + "'}";
            }).join("AND") + ")";
        })).join("OR");
    }

    build_match_array_query(cls, arr, field) {
        return uniq_arr(forMap(arr, val => {
            return "{'" + cls.fid(field) + "'.EX.'" + val + "'}";
        })).join("OR");
    }

    add_form(cls, params = {}) {
        params = mergeDeep({}, params);
        return this.call_api("API_GenAddRecordForm", cls, params, {form_response: true});
    }

    check_db_map(cls, db_map) {
        if (typeof (db_map) == "undefined") {
            return true;
        }
        let hsh = {};
        let duplicates = [];
        forEach(db_map, m => {
            if (!this.is_fake_field(m)) {
                if (hsh[m.fid] == true) {
                    duplicates.push(m.fid);
                }
                hsh[m.fid] = true;
            }
        });

        if (duplicates.length > 0) {
            throw new Error(`${cls.alias} db_map has duplicate fid ${duplicates.join(", ")}`);
        } else {
            return true;
        }
    }

    table_url(alias, url = this.application_url) {
        return url + "/(" + alias + ")";
    }

    set_current_user(include_roles = false, realm = this.realmhost_main_url, cls = this.application_url) {
        return this.get_user_info(realm).then(user => {
            this.current_user = user;
            if(include_roles){
                return this.get_user_roles(cls, {userid: user.id}).then(res => {
                    this.current_user.roles = res;
                });
            }
        });
    }

    record_class_init(klass) {
        klass.alias = "";
        klass.QBO = this;
        klass.db_map = [];
        klass.schema_fields = [];
        klass.schema_opt = {};
        klass.records = [];
        klass.query_opt = {};
        klass.save_opt = {};
        klass.load_method = "get";
        klass.model_key = underscorize(klass.name);

        forEach(["query", "get", "build_query", "build_slist", "query_delete", "run_import", "copy_master_detail", "upload_file", "build_match_objs_query", "build_match_array_query", "add_form", "fid", "fname"], func_name => {
            klass[func_name] = (...args) => klass.QBO[func_name](klass, ...args);
        });

        forEach(["save", "destroy", "add_record", "edit_record", "delete_file", "url_to"], func_name => {
            klass[func_name] = (...args) => klass.QBO[func_name](...args);
            klass.prototype[func_name] = function (...args) {
                return klass.QBO[func_name](this, ...args);
            };
        });
        // Still use QBO. for "authenticate", "get_users", "add_user_role", "get_user_roles", "get_user_info", "set_current_user"

        klass.url = () => klass.QBO.table_url(klass.alias);

        klass.update_db_map = (fid, obj) => {
            update_obj(klass.db_map, {fid: fid}, obj);
        };

        klass.load_records = () => {
            return klass[klass.load_method](klass.query_opt).then(arr => {
                klass.records = arr;
            });
        };

        klass.save_records = () => {
            if (klass.records.length == 0) {
                return new Promise((resolve) => resolve());
            } else {
                return klass.save(klass.records, klass.save_opt);
            }
        };

        klass.get_record = (rid) => {
            return get_obj(klass.records, {rid: rid});
        };

        klass.update_record = (rid, obj) => {
            update_obj(klass.records, {rid: rid}, obj);
        };

        klass.set_schema_fields = (update_db_map = true) => {
            return klass.QBO.get_schema(klass, klass.schema_opt).then(text => {
                let xml = new DOMParser().parseFromString(text);
                klass.table_label = xpath.select("//name", xml)[0].firstChild.data;
                klass.schema_fields = forMap(xpath.select("//field", xml), node => {
                    let field = xml_attrs(node);
                    xml_each_child(node, tag => {
                        if (tag.localName == 'choices') {
                            field.choices = [];
                            xml_each_child(tag, node => {
                                let choice = node.textContent;
                                if (!is_blank(choice)) {
                                    field.choices.push(choice);
                                }
                            });
                        } else {
                            field[tag.localName] = tag.textContent;
                        }
                    });
                    field.name = underscorize(field.label);

                    if (field.field_type == "recordid") {
                        field.name = "rid";
                    } else if (!is_blank(field.mode == "virtual" || field.mode == "lookup" || parseInt(field.id) < 6)) {
                        field.readonly = true;
                    }

                    field.required = field.required == "1";

                    return field;
                });
                if (update_db_map) {
                    klass.update_db_map();
                }
            });
        };

        klass.update_db_map = () => {
            klass.db_map = forMap(klass.db_map, map => {
                if (map.is_fake == true) {
                    return map;
                } else {
                    var new_map = {};
                    let schema_field = get_obj(klass.schema_fields, {id: map.fid});
                    if (typeof (schema_field) == "undefined") {
                        throw new Error("Field " + map.fid + " doesn't exist in table " + klass.name + ": " + klass.url());
                    } else {
                        ["field_type", "base_type", "required", "label", "choices", "num_lines", "maxlength", "readonly"].forEach(key => {
                            if (typeof (schema_field[key]) != "undefined") {
                                if (key == "choices") {
                                    new_map[key] = forMap(schema_field.choices, choice => {
                                        return {id: choice, name: choice};
                                    });
                                    new_map[key] = [{id: "", name: ""}].concat(new_map[key]);
                                } else {
                                    new_map[key] = schema_field[key];
                                }

                            }
                        });
                    }
                    return mergeDeep(new_map, map);
                }
            });
        };

        this.klasses.push(klass);
    }
};
